<!DOCTYPE html>
<html lang="zh-cn" itemscope itemtype="http://schema.org/WebPage">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>浅谈函数式编程（下）：核心概念 - Wang Junjie</title>
  

<meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta name="MobileOptimized" content="width"/>
<meta name="HandheldFriendly" content="true"/>


<meta name="applicable-device" content="pc,mobile">

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="mobile-web-app-capable" content="yes">

<meta name="author" content="Wang Junjie" />
  <meta name="description" content="本篇是《浅谈函数式编程》的下篇，主要讲解一些重要的函数式编程概念。 导读 导读：阅读本篇前，请思考如下问题： 函数式编程中如何从形式上消除结构化编" />







<meta name="generator" content="Hugo 0.51" />


<link rel="canonical" href="https://ijunjie.github.io/post/programming/fp-basic/" />



<link rel="icon" href="/favicon.ico" />











<link rel="stylesheet" href="/sass/jane.min.aaf3394fc81ccb6f6fe3fe458d1f5b61c39f151e44df83baaf1d7b3775a8b98d.css" integrity="sha256-qvM5T8gcy29v4/5FjR9bYcOfFR5E34O6rx17N3WouY0=" media="screen">





<meta property="og:title" content="浅谈函数式编程（下）：核心概念" />
<meta property="og:description" content="本篇是《浅谈函数式编程》的下篇，主要讲解一些重要的函数式编程概念。 导读 导读：阅读本篇前，请思考如下问题： 函数式编程中如何从形式上消除结构化编" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://ijunjie.github.io/post/programming/fp-basic/" /><meta property="article:published_time" content="2018-04-26T00:00:00&#43;00:00"/>
<meta property="article:modified_time" content="2018-04-26T00:00:00&#43;00:00"/>

<meta itemprop="name" content="浅谈函数式编程（下）：核心概念">
<meta itemprop="description" content="本篇是《浅谈函数式编程》的下篇，主要讲解一些重要的函数式编程概念。 导读 导读：阅读本篇前，请思考如下问题： 函数式编程中如何从形式上消除结构化编">


<meta itemprop="datePublished" content="2018-04-26T00:00:00&#43;00:00" />
<meta itemprop="dateModified" content="2018-04-26T00:00:00&#43;00:00" />
<meta itemprop="wordCount" content="6567">



<meta itemprop="keywords" content="fp," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="浅谈函数式编程（下）：核心概念"/>
<meta name="twitter:description" content="本篇是《浅谈函数式编程》的下篇，主要讲解一些重要的函数式编程概念。 导读 导读：阅读本篇前，请思考如下问题： 函数式编程中如何从形式上消除结构化编"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->




</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Wang Junjie</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://ijunjie.github.io/">Home</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://ijunjie.github.io/post/">Archives</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://ijunjie.github.io/tags/">Tags</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://ijunjie.github.io/categories/">Categories</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://ijunjie.github.io/about/">About</a>
          
        
      </li>
    
  </ul>
</nav>


  
    






  <link rel="stylesheet" href="/lib/photoswipe/photoswipe.min.css" />
  <link rel="stylesheet" href="/lib/photoswipe/default-skin/default-skin.min.css" />




<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

<div class="pswp__bg"></div>

<div class="pswp__scroll-wrap">
    
    <div class="pswp__container">
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
    </div>
    
    <div class="pswp__ui pswp__ui--hidden">
    <div class="pswp__top-bar">
      
      <div class="pswp__counter"></div>
      <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
      <button class="pswp__button pswp__button--share" title="Share"></button>
      <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
      <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
      
      
      <div class="pswp__preloader">
        <div class="pswp__preloader__icn">
          <div class="pswp__preloader__cut">
            <div class="pswp__preloader__donut"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
      <div class="pswp__share-tooltip"></div>
    </div>
    <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
    </button>
    <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
    </button>
    <div class="pswp__caption">
      <div class="pswp__caption__center"></div>
    </div>
    </div>
    </div>
</div>

  

  

  <header id="header" class="header container">
    <div class="logo-wrapper">
  <a href="/" class="logo">
    
      Wang Junjie
    
  </a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://ijunjie.github.io/">Home</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://ijunjie.github.io/post/">Archives</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://ijunjie.github.io/tags/">Tags</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://ijunjie.github.io/categories/">Categories</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://ijunjie.github.io/about/">About</a>
          

        

      </li>
    
    
  </ul>
</nav>

  </header>

  <div id="mobile-panel">
    <main id="main" class="main bg-llight">
      <div class="content-wrapper">
        <div id="content" class="content container">
          <article class="post bg-white">
    
    <header class="post-header">
      <h1 class="post-title">浅谈函数式编程（下）：核心概念</h1>
      
      <div class="post-meta">
        <time datetime="2018-04-26" class="post-time">
          2018-04-26
        </time>
        <div class="post-category">
            <a href="https://ijunjie.github.io/categories/programming/"> programming </a>
            
          </div>
        <span class="more-meta"> 约 6567 字 </span>
          <span class="more-meta"> 预计阅读 14 分钟 </span>

        
        

        
        
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#函数式编程">函数式编程</a></li>
<li><a href="#三板斧">三板斧</a>
<ul>
<li><a href="#map-和-filter">map 和 filter</a></li>
<li><a href="#reduce">reduce</a></li>
<li><a href="#collector">collector</a></li>
</ul></li>
<li><a href="#first-class-member">first-class member</a></li>
<li><a href="#lambda">lambda</a></li>
<li><a href="#高阶函数和柯里化">高阶函数和柯里化</a>
<ul>
<li><a href="#综合示例">综合示例</a></li>
</ul></li>
<li><a href="#纯函数和副作用">纯函数和副作用</a>
<ul>
<li><a href="#引用透明">引用透明</a></li>
</ul></li>
<li><a href="#function及其变体">Function及其变体</a>
<ul>
<li><a href="#function">Function</a></li>
<li><a href="#predicate">Predicate</a></li>
<li><a href="#supplier-consumer-runnable">Supplier, Consumer, Runnable</a></li>
</ul></li>
<li><a href="#闭包">闭包</a>
<ul>
<li><a href="#闭包对自由变量的读写">闭包对自由变量的读写</a></li>
<li><a href="#闭包的意义和局限性">闭包的意义和局限性</a></li>
</ul></li>
<li><a href="#flatmap和monad">flatmap和monad</a>
<ul>
<li><a href="#从类型角度分析flatmap">从类型角度分析flatmap</a></li>
<li><a href="#functor和monad">functor和monad</a></li>
</ul></li>
<li><a href="#函数式编程不是银弹">函数式编程不是银弹</a></li>
</ul></li>
</ul>
</nav>
  </div>
</div>

    
    <div class="post-content">
      

<p>本篇是《浅谈函数式编程》的下篇，主要讲解一些重要的函数式编程概念。</p>

<div class="shortcode-notice tip">
  <div class="shortcode-notice-title tip">
    
      导读
    
  </div>
  <p>导读：阅读本篇前，请思考如下问题：</p>

</div>


<ol>
<li>函数式编程中如何从形式上消除结构化编程所强调的选择和循环？</li>
<li>map, filter, reduce 如何实现整洁代码？</li>
<li>为什么说在函数式编程中，代码和数据之间没有明确的界限？</li>
<li>什么是lambda？不同的具有函数式编程特征的语言是如何支持lambda的？</li>
<li>什么是纯函数？什么是副作用？</li>
<li>什么是高阶函数，什么是柯里化？柯里化有什么意义？</li>
<li>什么是闭包？</li>
<li>flatmap和monad有什么联系？</li>
<li>为什么说函数式编程不是银弹？</li>
</ol>

<h2 id="函数式编程">函数式编程</h2>

<p>函数式编程可以看做声明式编程的一个子集。近年来，命令式编程语言越来越多地支持声明式（函数式）的编程特性。</p>

<div class="shortcode-notice tip">
  <div class="shortcode-notice-title tip">
    
      函数式特性
    
  </div>
  <p>支持函数式编程已然成为主流编程语言的标配。</p>

</div>


<p>实际上很多人已经在使用函数式编程了，如很多场合常见的map, filter，reduce. 其主要的特征体现的是与命令式截然不同的思想：不使用选择和循环（看不到if和for），而选择和循环是结构化编程的两个核心。</p>

<p>不同语言对函数式编程的支持能力有很大差别。一门语言是不是完全的函数式语言，其实并没有明确的界限。</p>

<p>函数式编程的核心思想是：不变、无副作用、无状态。各种概念都是建立在这个基础上的，概念之间环环相扣、互相有着深刻的联系。函数式编程认为，一个函数的返回值是表达计算结果的唯一形式（而不是把结果写入参数或借助副作用输出）。而实际上计算机最终必须通过IO与人交互。 正因如此，一些函数式编程语言做了很多工作来处理IO，由此也产生了不少难题。</p>

<p>本文要讨论的一些一些常见的、经典的函数式编程概念：</p>

<ul>
<li>map, reduce, filter</li>
<li>first-class member</li>
<li>lambda</li>
<li>high-order function，currying</li>
<li>pure function, side-effect</li>
<li>closure</li>
<li>flatmap, functor, monad</li>
</ul>

<h2 id="三板斧">三板斧</h2>

<p>上面提到的map, filter, reduce可以说是函数式编程的三板斧。也是很多初学函数式编程最先接触的三个函数。这三个函数很有用，即使仅仅学会这三个函数，也足以将代码整洁度提高一个档次。</p>

<p>在Android开发或者响应式编程，如RxJava/RxJS中，这三个函数是很常见的。</p>

<p>下面通过Javascript来看一下三个函数的用法：</p>

<h3 id="map-和-filter">map 和 filter</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">];</span>
<span class="kd">let</span> <span class="nx">r1</span> <span class="o">=</span> <span class="nx">a</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">e</span> <span class="p">=&gt;</span> <span class="nx">e</span> <span class="o">*</span> <span class="nx">e</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">r1</span><span class="p">);</span> <span class="c1">// [1, 4, 9, 16]
</span><span class="c1"></span>
<span class="kd">let</span> <span class="nx">r2</span> <span class="o">=</span> <span class="nx">r1</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="nx">e</span> <span class="p">=&gt;</span> <span class="nx">e</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">r2</span><span class="p">);</span> <span class="c1">// [4, 16]
</span><span class="c1"></span></code></pre></td></tr></table>
</div>
</div>
<h3 id="reduce">reduce</h3>

<p>在对一个集合中的元素按顺序两两操作时，根据某种策略得到一个结果，得到的结果参与下一次操作，最终被归约为一个结果，即reduce的返回值。</p>

<p>有时需要提供一个初始值，同第一个元素进行运算，返回的值同第二个元素进行运算，以此类推。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">];</span>
<span class="kd">let</span> <span class="nx">r3</span> <span class="o">=</span> <span class="nx">a</span><span class="p">.</span><span class="nx">reduce</span><span class="p">((</span><span class="nx">s</span><span class="p">,</span> <span class="nx">e</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">s</span> <span class="o">+</span> <span class="nx">e</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">r3</span><span class="p">);</span> <span class="c1">// 10
</span><span class="c1"></span></code></pre></td></tr></table>
</div>
</div>
<p>返回值可以是与几何元素不同的类型：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">];</span>
<span class="kd">let</span> <span class="nx">r3</span> <span class="o">=</span> <span class="nx">a</span><span class="p">.</span><span class="nx">reduce</span><span class="p">((</span><span class="nx">s</span><span class="p">,</span> <span class="nx">e</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">s</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nx">e</span><span class="p">),</span> <span class="s2">&#34;&#34;</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">r3</span><span class="p">);</span> <span class="c1">// 1234
</span><span class="c1"></span></code></pre></td></tr></table>
</div>
</div>
<p>reduce在很多语言中都有支持。只要掌握其原理，语言不是问题。</p>

<p>Java 8:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">names</span> <span class="o">=</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">&#34;hello&#34;</span><span class="o">,</span> <span class="s">&#34;world&#34;</span><span class="o">,</span> <span class="s">&#34;functional&#34;</span><span class="o">);</span>
<span class="n">String</span> <span class="n">longestName</span> <span class="o">=</span> <span class="n">names</span><span class="o">.</span><span class="na">stream</span>
        <span class="o">.</span><span class="na">reduce</span><span class="o">(</span><span class="s">&#34;program&#34;</span><span class="o">,</span> <span class="o">(</span><span class="n">u</span><span class="o">,</span> <span class="n">e</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">u</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&gt;=</span> <span class="n">e</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">?</span> <span class="nl">u:</span> <span class="n">e</span><span class="o">);</span>
<span class="n">Assert</span><span class="o">.</span><span class="na">assertTrue</span><span class="o">(</span><span class="n">longestName</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">&#34;functional&#34;</span><span class="o">));</span></code></pre></td></tr></table>
</div>
</div>
<p>reduce是Java 8的Stream的方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span> <span class="n">U</span> <span class="nf">reduce</span><span class="o">(</span><span class="n">U</span> <span class="n">identity</span><span class="o">,</span> <span class="n">BiFunction</span><span class="o">&lt;</span><span class="n">U</span><span class="o">,</span> <span class="n">T</span><span class="o">,</span> <span class="n">U</span><span class="o">&gt;</span> <span class="n">accumulator</span><span class="o">);</span></code></pre></td></tr></table>
</div>
</div>
<h3 id="collector">collector</h3>

<p>实际上在Java 8不会经常用直接用到reduce. 更常用的是Java 8提供的工具类Collectors.</p>

<p>下面的方法将一个Map翻转：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">static</span> <span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">V</span><span class="o">,</span> <span class="n">Set</span><span class="o">&lt;</span><span class="n">K</span><span class="o">&gt;&gt;</span> <span class="nf">reverse</span><span class="o">(</span><span class="n">Map</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">map</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">values</span><span class="o">().</span><span class="na">contains</span><span class="o">(</span><span class="kc">null</span><span class="o">))</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalArgumentException</span><span class="o">(</span><span class="s">&#34;Null value contained.&#34;</span><span class="o">);</span>

    <span class="k">return</span> <span class="n">map</span><span class="o">.</span><span class="na">entrySet</span><span class="o">().</span><span class="na">stream</span><span class="o">()</span>
            <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">Collectors</span><span class="o">.</span><span class="na">groupingBy</span><span class="o">(</span><span class="n">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">::</span><span class="n">getValue</span><span class="o">,</span>
                <span class="n">Collectors</span><span class="o">.</span><span class="na">mapping</span><span class="o">(</span><span class="n">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">::</span><span class="n">getKey</span><span class="o">,</span> <span class="n">Collectors</span><span class="o">.</span><span class="na">toSet</span><span class="o">())));</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p>下面看一个词频统计的例子：</p>

<p>传统命令式风格：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;</span> <span class="nf">frequency1</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">TreeMap</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;</span> <span class="n">wordMap</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeMap</span><span class="o">&lt;&gt;();</span>
    <span class="n">Matcher</span> <span class="n">m</span> <span class="o">=</span> <span class="n">Pattern</span><span class="o">.</span><span class="na">compile</span><span class="o">(</span><span class="s">&#34;\\w+&#34;</span><span class="o">).</span><span class="na">matcher</span><span class="o">(</span><span class="n">words</span><span class="o">);</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">m</span><span class="o">.</span><span class="na">find</span><span class="o">())</span> <span class="o">{</span>
        <span class="n">String</span> <span class="n">word</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="na">group</span><span class="o">().</span><span class="na">toLowerCase</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">NON_WORDS</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">word</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">Long</span> <span class="n">count</span> <span class="o">=</span> <span class="n">wordMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">word</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">count</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">wordMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">word</span><span class="o">,</span> <span class="n">1L</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">wordMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">word</span><span class="o">,</span> <span class="n">count</span> <span class="o">+</span> <span class="n">1L</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">wordMap</span><span class="o">;</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p>这段代码的特点：</p>

<ul>
<li>不同任务<strong>交织（complect）</strong>在一起，用一次循环完成多个任务</li>
<li>每次迭代中有三项操作：转换为小写，滤除虚词，计算词频</li>
<li>牺牲了代码的清晰，换取执行性能</li>
<li>包含大量if判断，使用循环————遵循了结构化编程原则。</li>
</ul>

<p>下面我们使用函数式编程风格重构。</p>

<p>实际上计算词频的几行代码可以使用<code>wordMap.merge(word, 1L, (a, b) -&gt; a + b)</code>代替。但仅仅是这一点不够彻底。完全的函数式风格要像下面这样：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;</span> <span class="nf">frequency2</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">reurn</span> <span class="nf">wordStream</span><span class="o">(</span><span class="n">words</span><span class="o">,</span> <span class="s">&#34;\\w+&#34;</span><span class="o">)</span>
            <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="nl">String:</span><span class="o">:</span><span class="n">toLowerCase</span><span class="o">)</span>
            <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">w</span> <span class="o">-&gt;!</span><span class="n">NON_WORDS</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">w</span><span class="o">))</span>
            <span class="o">.</span><span class="na">collect</span><span class="o">(</span>
                <span class="n">Collectors</span><span class="o">.</span><span class="na">groupingBy</span><span class="o">(</span>
                    <span class="n">Function</span><span class="o">.</span><span class="na">identity</span><span class="o">,</span><span class="nl">
</span><span class="nl">                    TreeMap:</span><span class="o">:</span><span class="k">new</span><span class="o">,</span>
                    <span class="n">Collectors</span><span class="o">.</span><span class="na">counting</span><span class="o">()));</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kd">static</span> <span class="n">Stream</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="nf">wordStream</span><span class="o">(</span><span class="n">String</span> <span class="n">words</span><span class="o">,</span> <span class="n">String</span> <span class="n">regex</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">Stream</span><span class="o">.</span><span class="na">Builder</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">builder</span> <span class="o">=</span> <span class="n">String</span><span class="o">.</span><span class="na">builder</span><span class="o">();</span>
    <span class="n">Matcher</span> <span class="n">matcher</span> <span class="o">=</span> <span class="n">Pattern</span><span class="o">.</span><span class="na">compile</span><span class="o">(</span><span class="n">regex</span><span class="o">).</span><span class="na">matcher</span><span class="o">(</span><span class="n">words</span><span class="o">);</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">matcher</span><span class="o">.</span><span class="na">find</span><span class="o">())</span> <span class="o">{</span>
        <span class="n">builder</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">matcher</span><span class="o">.</span><span class="na">group</span><span class="o">());</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">builder</span><span class="o">.</span><span class="na">build</span><span class="o">();</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p>抽取出滤除虚词的函数wordStream. 由于Matcher和Pattern本身的原因，wordStream的实现无法重构成函数式风格。</p>

<p>可以看到，重构后的frequency2方法有以下特点：</p>

<ul>
<li>使用map完成转换小写</li>
<li>使用filter完成虚词过滤</li>
<li>使用groupingBy完成词频统计</li>
<li>代码清晰</li>
<li>消除了显示的判断和循环</li>
<li>抽象层次得到提高</li>
</ul>

<h2 id="first-class-member">first-class member</h2>

<p>函数式编程语言中，函数通常作为一等公民（first-class member）. 其含义是，函数跟其他数据类型处于平等的位置。</p>

<ul>
<li>函数可以赋值给变量</li>
<li>函数可以作为参数</li>
<li>函数可以作为返回值</li>
</ul>

<p>有些OOP语言中，函数并不是一等公民（如Ruby），但仍然支持函数式编程风格。这跟基于对象有很大关系。如Java的Function，Ruby的method可以提取方法作为对象。</p>

<h2 id="lambda">lambda</h2>

<p>lambda是函数式编程的核心。简单讲，lambda就是<strong>匿名函数</strong>。</p>

<p>不同语言对lambda的支持形式不同，约束也不同。关于函数、lambda和闭包的区别，请参考闭包一节。</p>

<p>下面是一些语言中的lambda形式：</p>

<p>Javascript:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">let</span> <span class="nx">f</span> <span class="o">=</span> <span class="nx">i</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div>
<p>Java:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="n">Consumer</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">f</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-&gt;</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">i</span><span class="o">);</span></code></pre></td></tr></table>
</div>
</div>
<p>Scala:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">f</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=&gt;</span> <span class="nc">Unit</span> <span class="k">=</span> <span class="n">i</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">i</span><span class="o">)</span></code></pre></td></tr></table>
</div>
</div>
<p>Ruby:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-ruby" data-lang="ruby"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-ruby" data-lang="ruby"><span class="n">f</span> <span class="o">=</span> <span class="nb">lambda</span> <span class="p">{</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span>
  <span class="n">put</span> <span class="n">i</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>Groovy:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-groovy" data-lang="groovy"><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-groovy" data-lang="groovy"><span class="kt">def</span> <span class="n">f1</span> <span class="o">=</span> <span class="o">{</span> <span class="n">i</span> <span class="o">-&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">i</span><span class="o">)}</span>
<span class="kt">def</span> <span class="n">f2</span> <span class="o">=</span> <span class="o">{</span> <span class="n">println</span> <span class="n">it</span><span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p>Python:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="k">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span></code></pre></td></tr></table>
</div>
</div>
<h2 id="高阶函数和柯里化">高阶函数和柯里化</h2>

<p>高阶函数简单来讲就是<strong>接受函数作为参数</strong>或<strong>返回函数</strong>的函数。</p>

<p>柯里化的函数具有多个参数列表。</p>

<p>“柯里”来自于著名数学家<strong>Haskell B. Curry</strong>. 没错，就是编程语言Haskell的Haskell。他的名字和姓氏分别成为了一门编程语言的名字和一个函数式概念的名字。</p>

<p>来看一下柯里化：</p>

<p>Javascript正常写法，调用时传递多个参数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">let</span> <span class="nx">f1</span> <span class="o">=</span> <span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">r1</span> <span class="o">=</span> <span class="nx">f1</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="err">；</span>
</code></pre></td></tr></table>
</div>
</div>
<p>柯里化：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">let</span> <span class="nx">f2</span> <span class="o">=</span> <span class="nx">a</span> <span class="p">=&gt;</span> <span class="nx">b</span> <span class="p">=&gt;</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">r2</span> <span class="o">=</span> <span class="nx">f2</span><span class="p">(</span><span class="mi">1</span><span class="p">)(</span><span class="mi">2</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div>
<p>可以看到，通过高阶函数可以实现拆分参数列表。实际上每个参数列表对应返回的是一个Partial Application.</p>

<p>柯里化是一种常用的函数式编程技巧。在一些语言中也可以用于辅助类型推断。</p>

<p>下面我们看一个高阶函数和递归综合运用的例子。</p>

<h3 id="综合示例">综合示例</h3>

<p>下面我们通过一个javascript例子，一步步完成匿名函数的递归调用，展示高阶函数、递归、柯里化、IIFE的使用技巧。</p>

<p><strong>函数自调</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="nx">f</span> <span class="p">=&gt;</span> <span class="nx">f</span><span class="p">(</span><span class="nx">f</span><span class="p">);</span>
<span class="kd">let</span> <span class="nx">r</span> <span class="o">=</span> <span class="nx">a</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">f1</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">});</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">r</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div>
<p>这段代码首先定义了一个匿名函数a, a接收一个函数f，并用这个函数调用自身f(f). 也就是说这个f本身的参数也是一个函数。</p>

<p>接下来向a传参。这里传入的参数是<code>function(f1) {return 2;}</code>. 为了区分这里没有使用箭头函数。</p>

<p>a拿到这个参数后，执行f(f)自调，意味着f1又是<code>function(f1) {return 2}</code>. 但实际在函数体中并没有用到f1，而是直接返回了2.我们加入一行日志，查看一下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="nx">f</span> <span class="p">=&gt;</span> <span class="nx">f</span><span class="p">(</span><span class="nx">f</span><span class="p">);</span>
<span class="kd">let</span> <span class="nx">r</span> <span class="o">=</span> <span class="nx">a</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">f1</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">f1</span><span class="p">.</span><span class="nx">toString</span><span class="p">());</span>
  <span class="k">return</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">});</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">r</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div>
<p>Javascript的传参方式是很灵活的，多传参数不会有影响：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="nx">f</span> <span class="p">=&gt;</span> <span class="nx">f</span><span class="p">(</span><span class="nx">f</span><span class="p">);</span>
<span class="kd">let</span> <span class="nx">r</span> <span class="o">=</span> <span class="nx">a</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">f1</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">f1</span><span class="p">.</span><span class="nx">toString</span><span class="p">());</span>
  <span class="k">return</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">},</span> <span class="s2">&#34;hello&#34;</span><span class="p">,</span> <span class="s2">&#34;world&#34;</span><span class="p">,</span> <span class="s2">&#34;foo&#34;</span><span class="p">,</span> <span class="s2">&#34;bar&#34;</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">r</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div>
<p>额外传递的参数会被a忽略。</p>

<p>接下来我们对a进行一些改造，使a接收的函数可以附带参数。</p>

<p><strong>带参数的函数自调</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">f</span><span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="nx">n</span><span class="p">);</span>
<span class="kd">let</span> <span class="nx">r</span> <span class="o">=</span> <span class="nx">a</span><span class="p">((</span><span class="nx">f1</span><span class="p">,</span> <span class="nx">n1</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">n1</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">},</span> <span class="mi">1</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">r</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div>
<p>在这段代码中，1首先作为a的第二个参数传给n，然后实际又传给了f的第二个参数。f和a具有相同的结构。</p>

<p>接下来进行柯里化改造：</p>

<p><strong>柯里化</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="nx">f</span> <span class="p">=&gt;</span> <span class="nx">n</span> <span class="p">=&gt;</span> <span class="nx">f</span><span class="p">(</span><span class="nx">f</span><span class="p">)(</span><span class="nx">n</span><span class="p">);</span>
<span class="kd">let</span> <span class="nx">r</span> <span class="o">=</span> <span class="nx">a</span><span class="p">(</span><span class="nx">f1</span> <span class="p">=&gt;</span> <span class="nx">n1</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">n1</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">})(</span><span class="mi">1</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div>
<p>可以看到，通过高阶函数将a和f都拆分成多个参数列表。</p>

<p><strong>IIFE</strong></p>

<p>IIFE是 <code>Immediately Invoked Function Expression</code> 的缩写。用于一次性匿名函数的调用。</p>

<p>上面的代码可以省去中间变量a.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">let</span> <span class="nx">r</span> <span class="o">=</span> <span class="p">(</span><span class="nx">f</span> <span class="p">=&gt;</span> <span class="nx">n</span> <span class="p">=&gt;</span> <span class="nx">f</span><span class="p">(</span><span class="nx">f</span><span class="p">)(</span><span class="nx">n</span><span class="p">))(</span><span class="nx">f1</span> <span class="p">=&gt;</span> <span class="nx">n1</span> <span class="p">=&gt;</span> <span class="mi">2</span><span class="p">)(</span><span class="mi">1</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div>
<p><strong>最大公约数示例</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">let</span> <span class="nx">gcd</span> <span class="o">=</span> <span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">(</span><span class="nx">f</span> <span class="p">=&gt;</span> <span class="nx">a</span> <span class="p">=&gt;</span> <span class="nx">b</span> <span class="p">=&gt;</span> <span class="nx">f</span><span class="p">(</span><span class="nx">f</span><span class="p">)(</span><span class="nx">a</span><span class="p">)(</span><span class="nx">b</span><span class="p">))</span>
  <span class="p">(</span><span class="nx">f</span> <span class="p">=&gt;</span> <span class="nx">a</span> <span class="p">=&gt;</span> <span class="nx">b</span> <span class="p">=&gt;</span> <span class="nx">b</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="nx">a</span> <span class="o">:</span> <span class="nx">f</span><span class="p">(</span><span class="nx">f</span><span class="p">)(</span><span class="nx">b</span><span class="p">)(</span><span class="nx">a</span> <span class="o">%</span> <span class="nx">b</span><span class="p">))</span>
  <span class="p">(</span><span class="nx">x</span><span class="p">)</span>
  <span class="p">(</span><span class="nx">y</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">gcd</span><span class="p">(</span><span class="mi">66</span><span class="p">,</span> <span class="mi">42</span><span class="p">));</span>
</code></pre></td></tr></table>
</div>
</div>
<p>这个示例需要在较高版本的Firefox或Chrome运行.</p>

<h2 id="纯函数和副作用">纯函数和副作用</h2>

<p>所谓纯函数是指，返回的结果仅仅依赖于传入的参数，不依赖外部变量和全局状态。</p>

<p>副作用：函数式思想认为，一个函数唯一的与所在环境交流的方式就是获得参数和返回结果。除此之外产生的改变都是副作用。</p>

<p>副作用是从函数的视角来看的，仅仅是叫做“副作用”。有些情况下，特别是命令式语言，涉及到数据结构和IO处理时，需要的恰恰是副作用，返回值当做了副产品。这是不符合函数式原则的。</p>

<h3 id="引用透明">引用透明</h3>

<p>与纯函数和副作用密切相关的一个概念是引用透明。引用透明是指，表达式（引用）和值可以相互替换，无副作用，不影响函数结果。</p>

<p>这里参考了<strong>雪川大虫</strong>的介绍。雪川大虫有一系列关于泛函编程和Scalaz的文章，是学习Scala的非常有价值的资源。</p>

<p>Scala:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">var</span> <span class="n">x</span> <span class="k">=</span> <span class="s">&#34;Hello World&#34;</span>
<span class="k">var</span> <span class="n">r1</span> <span class="k">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reverse</span>
<span class="k">var</span> <span class="n">r2</span> <span class="k">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reverse</span> <span class="o">//</span> <span class="n">r1和r2中的x都可以替换为</span><span class="s">&#34;Hello World&#34;</span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">var</span> <span class="n">y</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">(</span><span class="s">&#34;Hello&#34;</span><span class="o">)</span>
<span class="k">var</span> <span class="n">z</span> <span class="k">=</span> <span class="n">y</span><span class="o">.</span><span class="n">append</span><span class="o">(</span><span class="s">&#34;, World&#34;</span><span class="o">)</span>

<span class="k">var</span> <span class="n">r3</span> <span class="k">=</span> <span class="n">z</span><span class="o">.</span><span class="n">toString</span><span class="o">()</span>
<span class="k">var</span> <span class="n">r4</span> <span class="k">=</span> <span class="n">z</span><span class="o">.</span><span class="n">toString</span><span class="o">()</span>
<span class="k">var</span> <span class="n">r5</span> <span class="k">=</span> <span class="n">z</span><span class="o">.</span><span class="n">toString</span><span class="o">()</span></code></pre></td></tr></table>
</div>
</div>
<p>这段代码中，r3, r4, r5中的z是不能替换为y.append(&ldquo;, World&rdquo;)的。因为append不是一个引用透明的操作。</p>

<h2 id="function及其变体">Function及其变体</h2>

<p>基于纯函数的思想，对参数、返回值和副作用进行搭配组合，可以得到一些变体。从实用角度看这些变体能满足各种实际需求。</p>

<p>这里采用Java 8中的概念。实际上其他语言也大致通用。</p>

<table>
<thead>
<tr>
<th align="center">概念</th>
<th align="center">参数</th>
<th align="center">返回值</th>
<th align="center">副作用</th>
<th align="center">备注</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">Function</td>
<td align="center">有</td>
<td align="center">有</td>
<td align="center">无</td>
<td align="center">函数式编程的核心</td>
</tr>

<tr>
<td align="center">Predicate</td>
<td align="center">有</td>
<td align="center">Boolean</td>
<td align="center">无</td>
<td align="center">固定返回值为Boolean类型</td>
</tr>

<tr>
<td align="center">Supplier</td>
<td align="center">无</td>
<td align="center">有</td>
<td align="center">无</td>
<td align="center">不通过参数提供返回值</td>
</tr>

<tr>
<td align="center">Consumer</td>
<td align="center">有</td>
<td align="center">无</td>
<td align="center">有</td>
<td align="center">对参数进行处理，需要的是副作用</td>
</tr>

<tr>
<td align="center">Runnable</td>
<td align="center">无</td>
<td align="center">无</td>
<td align="center">有</td>
<td align="center">运行某种任务的过程；<br>（实际的参数在对象上下文中）</td>
</tr>
</tbody>
</table>

<p>下面的代码都是以Java 8代码结合OOP来讲的。由于在Java中函数不是一类对象，对函数式编程的支持是用类型和对象实现的。对开发者而言，这样做更容易接受。如在Stream上用<code>.</code>即可调用map, filter, 而在python中函数式和OOP结合的不好，map仍然是个函数而不是方法。</p>

<h3 id="function">Function</h3>

<ul>
<li>Function<T, R>, T为参数类型， R为返回值类型；jdk也提供了BiFunction<T, U, R>, T和U为参数类型</li>
<li>方法：apply</li>
<li>identity方法：返回自身 x -&gt; x</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="n">Function</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">f1</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-&gt;</span> <span class="n">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
<span class="n">Function</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">f2</span> <span class="o">=</span> <span class="nl">String:</span><span class="o">:</span><span class="n">valueOf</span><span class="o">;</span> <span class="c1">// method reference
</span><span class="c1"></span>
<span class="n">String</span> <span class="n">r1</span> <span class="o">=</span> <span class="n">f1</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="n">2</span><span class="o">);</span>

<span class="n">Function</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">returnSelf</span> <span class="o">=</span> <span class="n">Function</span><span class="o">.</span><span class="na">identity</span><span class="o">();</span></code></pre></td></tr></table>
</div>
</div>
<h3 id="predicate">Predicate</h3>

<ul>
<li>Predicate<T>, T为参数类型，返回值为Boolean，可以看做Function<T, Boolean></li>
<li>方法：test</li>
<li>BiPredicate</li>
<li>通常作为filter的参数</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="n">Predicate</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">pred1</span> <span class="o">=</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span>
<span class="n">BiPredicate</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">pred2</span> <span class="o">=</span> <span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">i</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="kc">true</span><span class="o">;</span>
<span class="kt">boolean</span> <span class="n">test1</span> <span class="o">=</span> <span class="n">pred1</span><span class="o">.</span><span class="na">test</span><span class="o">(</span><span class="s">&#34;hello&#34;</span><span class="o">);</span></code></pre></td></tr></table>
</div>
</div>
<h3 id="supplier-consumer-runnable">Supplier, Consumer, Runnable</h3>

<ul>
<li>Supplier<T>, 无参数，返回值为T类型，可看做Function<Void, T>, 方法get</li>
<li>Consumer<T>, 无返回值，参数类型为T，可看做Function<T, Void>, 方法accept</li>
<li>Runnable无参数，无返回值</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="n">Supplier</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">supplier</span> <span class="o">=</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="s">&#34;hello&#34;</span><span class="o">;</span>
<span class="n">String</span> <span class="n">r</span> <span class="o">=</span> <span class="n">supplier</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>

<span class="n">Consumer</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">consumer</span> <span class="o">=</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">;</span>
<span class="n">consumer</span><span class="o">.</span><span class="na">accept</span><span class="o">(</span><span class="s">&#34;hello&#34;</span><span class="o">);</span>

<span class="n">Runnable</span> <span class="n">runnable</span> <span class="o">=</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="o">{};</span></code></pre></td></tr></table>
</div>
</div>
<p>jdk同样也提供了以Bi开头的函数接口，如BiConsumer等，可以避免用户自行封装类型。</p>

<h2 id="闭包">闭包</h2>

<p>闭包是指，一个函数在<strong>运行时</strong>， 捕获<strong>自由变量</strong>并关闭。这个运行时的函数对象叫做闭包。</p>

<p>常见的闭包通常是嵌套在外部作用域中的私有函数。</p>

<p>自由变量和绑定变量：在函数的上下文中，有明确意义的变量叫做<strong>绑定变量</strong>，函数文本不能给出明确意义的变量叫做<strong>自由变量</strong>。</p>

<p>严格意义上的闭包是包含了<strong>自由变量</strong>的函数。这一点是区分闭包与（纯）函数的关键。</p>

<p>下面的表格展示了函数、lambda和闭包的区别。</p>

<table>
<thead>
<tr>
<th>-</th>
<th>Function</th>
<th>Lambda</th>
<th>Closure</th>
</tr>
</thead>

<tbody>
<tr>
<td>Named</td>
<td>Named/Anonymous</td>
<td>Anonymous</td>
<td>Named/Anonymous</td>
</tr>

<tr>
<td>Have free variables</td>
<td>Yes/No</td>
<td>Yes/No</td>
<td>Yes</td>
</tr>
</tbody>
</table>

<p>从这个表中可以看出，lambda区别与Function的关键点是匿名；closure区别于Function的关键点是包含自由变量；closure也是一种lambda.</p>

<p>（BTW，如果拿Method与它们三个比较，则Method是OOP的概念，它们三个是FP的概念。Method带有对象上下文，要处理this.）</p>

<p>Javascript闭包示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">outer</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">&lt;</span><span class="mi">5</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">a</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="p">};</span>

<span class="nx">outer</span><span class="p">()();</span>
</code></pre></td></tr></table>
</div>
</div>
<p>这段代码中，() =&gt; console.log(i);是一个lambda形式的闭包，因为i是自由变量。这个闭包只有在真正运行的时候才会去捕获i的值。因此最后outer()返回了该闭包，执行闭包时i已经变成5了。</p>

<p>假定我们这里希望输出的是1，那么如何修改？思路很简单，只要尽早获取i的值就可以了。</p>

<p>如： <code>a[i] = new Function(&quot;console.log(&quot; + i +&quot;);&quot;)</code></p>

<p>这句代码的关键是拼接字符串的表达式。表达式的计算是优先的，先于Function的构造。所以Function的构造中已经获取到了期望的i的值。</p>

<p>当然，除了用表达式之外，也有别的方式，如IIFE，采用最新的let语法等。</p>

<h3 id="闭包对自由变量的读写">闭包对自由变量的读写</h3>

<p>在很多语言中，自由变量的值发生变化后，闭包是可以感知到的。</p>

<p>Javascript：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">more</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="nx">x</span> <span class="p">=&gt;</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">more</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">f</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span>
<span class="nx">more</span> <span class="o">=</span> <span class="mi">9</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">f</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span>
</code></pre></td></tr></table>
</div>
</div>
<p>有些语言中，闭包可以修改自由变量，如Javascript；有些语言中自由变量在闭包中是只读的，如Java.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">];</span>
<span class="nx">arr</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">e</span> <span class="p">=&gt;</span> <span class="nx">sum</span> <span class="o">+=</span> <span class="nx">e</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">sum</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="n">String</span> <span class="n">result</span> <span class="o">=</span> <span class="s">&#34;&#34;</span><span class="o">;</span> <span class="c1">// 要求effectively final
</span><span class="c1"></span><span class="n">Optional</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">&#34;hello&#34;</span><span class="o">).</span><span class="na">ifPresent</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">s</span><span class="o">);</span> <span class="o">//</span><span class="n">编译不通过</span></code></pre></td></tr></table>
</div>
</div>
<h3 id="闭包的意义和局限性">闭包的意义和局限性</h3>

<ul>
<li>闭包延长了自由变量的声明周期，利用这一点可以用闭包模拟对象，实现对象机制</li>
<li>间接保持对象的值会给垃圾回收带来难题，也会降低性能</li>
<li>闭包使函数具有了保存数据的能力，但又不足以实现完善的面向对象能力</li>
</ul>

<h2 id="flatmap和monad">flatmap和monad</h2>

<p>这一节难度较高，如果只是想简单了解一下函数式编程，这一节可以略去不看。</p>

<p>flatmap可以看做flat + map, 但这并不是问题的本质。下面我们从类型的角度来看一下flatmap.</p>

<p>先看flatmap的用法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="n">Stream</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="n">listStream</span> <span class="o">=</span>
    <span class="n">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="n">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="n">1</span><span class="o">,</span> <span class="n">2</span><span class="o">),</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="n">3</span><span class="o">,</span> <span class="n">4</span><span class="o">)).</span><span class="na">stream</span><span class="o">();</span>
<span class="n">Stream</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">integerStream</span> <span class="o">=</span> <span class="n">listStream</span><span class="o">.</span><span class="na">flatMap</span><span class="o">(</span><span class="n">lst</span> <span class="o">-&gt;</span> <span class="n">lst</span><span class="o">.</span><span class="na">stream</span><span class="o">());</span>
<span class="n">integerStream</span><span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span></code></pre></td></tr></table>
</div>
</div>
<p>上面这段代码将嵌套的list拉平了，没有体现map. 修改一下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="n">Stream</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">stringStream</span> <span class="o">=</span> <span class="n">listStream</span><span class="o">.</span><span class="na">flatMap</span><span class="o">(</span><span class="n">lst</span> <span class="o">-&gt;</span> <span class="n">lst</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">map</span><span class="o">(</span><span class="n">i</span> <span class="o">-&gt;</span> <span class="s">&#34;[&#34;</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="s">&#34;]&#34;</span><span class="o">));</span></code></pre></td></tr></table>
</div>
</div>
<p>可以看到 flatmap的确是flat + map的过程。</p>

<h3 id="从类型角度分析flatmap">从类型角度分析flatmap</h3>

<p>从类型角度来看：</p>

<blockquote>
<p>Stream<List<Integer>&gt; 转换为 Stream<String>, flatMap的参数是 从List<Integer> 到 Stream<String> 的函数</p>
</blockquote>

<p>从<code>List&lt;Integer&gt;</code>的流变成<code>Integer的流</code>体现了flat，但从类型上看<code>List&lt;Integer&gt;</code>和<code>String</code>是两个毫无关系的类型。我们把<code>Stream</code>抽象成Type，把<code>List&lt;Integer&gt;</code>抽象成T，把<code>String</code>抽象成U，可以得到</p>

<blockquote>
<p>Type<T> 转换为 <code>Type&lt;U&gt;</code>, flatMap的参数是 从 T 到 <code>Type&lt;U&gt;</code> 的函数</p>
</blockquote>

<p>是的，这就是flatmap的本质。如果转换的方式不是从 <code>T</code> 到 <code>Type&lt;U&gt;</code>, 而是从 <code>T</code> 到 <code>U</code>， 就成了 map.</p>

<p>用类型来描述flatmap：</p>

<ul>
<li>是<code>Type&lt;T&gt;</code>的方法</li>
<li>如果看做Function，则类型描述为 <code>Function&lt;Function&lt;T, Type&lt;U&gt;&gt;, Type&lt;U&gt;&gt;</code></li>
<li>从OOP角度看，flatmap的第一个参数是this, 所以flatmap的完整形式应该是<code>Type&lt;U&gt; flatMap(Type&lt;T&gt; self, Function&lt;T, Type&lt;U&gt;&gt; f)</code></li>
</ul>

<p>下面我们来证明CompletionStage的thenCompose方法也是flatmap:</p>

<p>准备两种类型 T 和 U:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">static</span> <span class="kd">class</span> <span class="nc">T</span><span class="o">{}</span>
<span class="kd">static</span> <span class="kd">class</span> <span class="nc">U</span><span class="o">{}</span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="n">Stream</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">st</span> <span class="o">=</span> <span class="n">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="k">new</span> <span class="n">T</span><span class="o">());</span>
<span class="n">Function</span><span class="o">&lt;</span><span class="n">Function</span><span class="o">&lt;</span><span class="n">T</span><span class="o">,</span> <span class="n">Stream</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;&gt;,</span> <span class="n">Stream</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;&gt;</span> <span class="n">flatmap1</span> <span class="o">=</span> <span class="nl">st:</span><span class="o">:</span><span class="n">flatMap</span><span class="o">;</span>

<span class="n">Function</span><span class="o">&lt;</span><span class="n">T</span><span class="o">,</span> <span class="n">U</span><span class="o">&gt;</span> <span class="n">t2u</span> <span class="o">=</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="n">U</span><span class="o">();</span>
<span class="n">CompletionStage</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">ct</span> <span class="o">=</span> <span class="n">CompletableFuture</span><span class="o">.</span><span class="na">completedFuture</span><span class="o">(</span><span class="k">new</span> <span class="n">T</span><span class="o">());</span>

<span class="n">Function</span><span class="o">&lt;</span><span class="n">Function</span><span class="o">&lt;</span><span class="n">T</span><span class="o">,</span> <span class="n">CompletionStage</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;&gt;,</span> <span class="n">CompletionStage</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;&gt;</span> <span class="n">alsoFlatmap</span> <span class="o">=</span> <span class="nl">ct:</span><span class="o">:</span><span class="n">thenCompose</span><span class="o">;</span></code></pre></td></tr></table>
</div>
</div>
<p>最后一句证明了thenCompose实际也是flatmap.</p>

<h3 id="functor和monad">functor和monad</h3>

<ul>
<li>一个functor(函子)是一种表示为<code>Type&lt;T&gt;</code>的类型。它封装了另一种类型，具有<code>(T-&gt;U) -&gt; Type&lt;U&gt;</code>签名的map方法</li>
<li>一个monad(单子)是一种类型，它是一个functor，同时具有<code>(T-&gt;Type&lt;U&gt;) -&gt; Type&lt;U&gt;</code>签名的flatmap方法</li>
</ul>

<p>这是简明扼要的描述。实际monad的理论比较复杂。monad是为了处理IO副作用而出现的。</p>












  





  


<blockquote>
  <p>谈论monad的第一原则是不要谈论monad；第二原则是不要读别人的关于monad的文章;第三原则是不要发表关于monad的文章误导他人。</p>
  <footer>
    <strong></strong>
    
      
        
      
    
  </footer>
</blockquote>


<h2 id="函数式编程不是银弹">函数式编程不是银弹</h2>

<p>最后，我们用一句带有道德训诫意味话做本篇的收尾——FP不是银弹。</p>

<p>银弹在计算机领域常用来指代某种策略、技术或技巧，可以极大解放程序员的生产力。</p>

<p>《没有银弹》是Fred Brooks在1987年发表的一片关于软件工程的经典论文。论文中强调真正的银弹并不存在。没有任何一项技术或方法可以让软件工程的生产力在十年内提高十倍。这篇论文的核心思想通常被解释为<strong>复杂的软件工程问题无法靠简单的答案来解决</strong>。</p>

<p>函数式编程的局限性：</p>

<ul>
<li>需要副作用的操作：流程控制、顺序操作、状态维护、IO运算</li>
<li>表现力、执行效率问题。函数式编程风格接近于数学运算，没有受过训练的程序员难以理解表意密度极高的代码；执行效率上一般来说也不如命令式，因为计算机操作系统底层归根结底还是命令式的。</li>
</ul>

<p>函数式编程的用武之地：</p>

<ul>
<li>并行计算、并发模型</li>
<li>大数据处理</li>
<li>人工智能</li>
</ul>

<p>人类社会创造的一切事物都在朝着更加智能的方向进化。声明式、函数式、逻辑式编程是面向未来的编程思想，把更多工作交给机器去做，注重提高人的效率，而不是机器的效率。</p>

<p>（完）</p>

    </div>

    
    
<div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">Wang Junjie</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">2018-04-26</span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">许可协议</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">CC BY-NC-ND 4.0</a></span>
  </p>
</div>


    
    

    <footer class="post-footer">
      <div class="post-tags">
          <a href="https://ijunjie.github.io/tags/fp/">fp</a>
          
        </div>

      
      <nav class="post-nav">
        
          <a class="prev" href="/post/myworks/xiriwochuo/">
            
            <i class="iconfont">
              <svg  class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M691.908486 949.511495l75.369571-89.491197c10.963703-12.998035 10.285251-32.864502-1.499144-44.378743L479.499795 515.267417 757.434875 204.940602c11.338233-12.190647 11.035334-32.285311-0.638543-44.850487l-80.46666-86.564541c-11.680017-12.583596-30.356378-12.893658-41.662889-0.716314L257.233596 494.235404c-11.332093 12.183484-11.041474 32.266891 0.657986 44.844348l80.46666 86.564541c1.772366 1.910513 3.706415 3.533476 5.750981 4.877077l306.620399 321.703933C662.505829 963.726242 680.945807 962.528973 691.908486 949.511495z"></path>
</svg>

            </i>
            <span class="prev-text nav-default">昔日龌龊不足夸</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        
          <a class="next" href="/post/programming/fp-paradigm/">
            <span class="next-text nav-default">浅谈函数式编程（上）：编程范式</span>
            <span class="prev-text nav-mobile">下一篇</span>
            
            <i class="iconfont">
              <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M332.091514 74.487481l-75.369571 89.491197c-10.963703 12.998035-10.285251 32.864502 1.499144 44.378743l286.278095 300.375162L266.565125 819.058374c-11.338233 12.190647-11.035334 32.285311 0.638543 44.850487l80.46666 86.564541c11.680017 12.583596 30.356378 12.893658 41.662889 0.716314l377.434212-421.426145c11.332093-12.183484 11.041474-32.266891-0.657986-44.844348l-80.46666-86.564541c-1.772366-1.910513-3.706415-3.533476-5.750981-4.877077L373.270379 71.774697C361.493148 60.273758 343.054193 61.470003 332.091514 74.487481z"></path>
</svg>

            </i>
          </a>
      </nav>
    </footer>
  </article>

  
  
  
  

  
  

  
  

  

  

  
  
    



        </div>
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
  
    <a href="mailto:wang-junjie@outlook.com" rel="me noopener" class="iconfont"
      title="email" >
      <svg class="icon" viewBox="0 0 1451 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M664.781909 681.472759 0 97.881301C0 3.997201 71.046997 0 71.046997 0L474.477909 0 961.649408 0 1361.641813 0C1361.641813 0 1432.688811 3.997201 1432.688811 97.881301L771.345323 681.472759C771.345323 681.472759 764.482731 685.154773 753.594283 688.65053L753.594283 688.664858C741.602731 693.493018 729.424896 695.068979 718.077952 694.839748 706.731093 695.068979 694.553173 693.493018 682.561621 688.664858L682.561621 688.65053C671.644501 685.140446 664.781909 681.472759 664.781909 681.472759L664.781909 681.472759ZM718.063616 811.603883C693.779541 811.016482 658.879232 802.205449 619.10784 767.734955 542.989056 701.759633 0 212.052267 0 212.052267L0 942.809523C0 942.809523 0 1024 83.726336 1024L682.532949 1024 753.579947 1024 1348.948139 1024C1432.688811 1024 1432.688811 942.809523 1432.688811 942.809523L1432.688811 212.052267C1432.688811 212.052267 893.138176 701.759633 817.019477 767.734955 777.248 802.205449 742.347691 811.03081 718.063616 811.603883L718.063616 811.603883Z"></path>
</svg>

    </a>
  
    <a href="https://github.com/ijunjie" rel="me noopener" class="iconfont"
      title="github"  target="_blank"
      >
      <svg class="icon" style="" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M512 12.672c-282.88 0-512 229.248-512 512 0 226.261333 146.688 418.133333 350.08 485.76 25.6 4.821333 34.986667-11.008 34.986667-24.618667 0-12.16-0.426667-44.373333-0.64-87.04-142.421333 30.890667-172.458667-68.693333-172.458667-68.693333C188.672 770.986667 155.008 755.2 155.008 755.2c-46.378667-31.744 3.584-31.104 3.584-31.104 51.413333 3.584 78.421333 52.736 78.421333 52.736 45.653333 78.293333 119.850667 55.68 149.12 42.581333 4.608-33.109333 17.792-55.68 32.426667-68.48-113.706667-12.8-233.216-56.832-233.216-253.013333 0-55.893333 19.84-101.546667 52.693333-137.386667-5.76-12.928-23.04-64.981333 4.48-135.509333 0 0 42.88-13.738667 140.8 52.48 40.96-11.392 84.48-17.024 128-17.28 43.52 0.256 87.04 5.888 128 17.28 97.28-66.218667 140.16-52.48 140.16-52.48 27.52 70.528 10.24 122.581333 5.12 135.509333 32.64 35.84 52.48 81.493333 52.48 137.386667 0 196.693333-119.68 240-233.6 252.586667 17.92 15.36 34.56 46.762667 34.56 94.72 0 68.522667-0.64 123.562667-0.64 140.202666 0 13.44 8.96 29.44 35.2 24.32C877.44 942.592 1024 750.592 1024 524.672c0-282.752-229.248-512-512-512"></path>
</svg>

    </a>


<a href="https://ijunjie.github.io/index.xml" rel="noopener alternate" type="application/rss&#43;xml"
    class="iconfont" title="rss" target="_blank">
    <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="30" height="30">
  <path d="M819.157333 1024C819.157333 574.592 449.408 204.8 0 204.8V0c561.706667 0 1024 462.293333 1024 1024h-204.842667zM140.416 743.04a140.8 140.8 0 0 1 140.501333 140.586667A140.928 140.928 0 0 1 140.074667 1024C62.72 1024 0 961.109333 0 883.626667s62.933333-140.544 140.416-140.586667zM678.784 1024h-199.04c0-263.210667-216.533333-479.786667-479.744-479.786667V345.173333c372.352 0 678.784 306.517333 678.784 678.826667z"></path>
</svg>

  </a>
  
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - <a class="theme-link" href="https://github.com/xianmin/hugo-theme-jane">Jane</a>
  </span>

  <span class="copyright-year">
    &copy;
    
      2017 -
    2018
    <span class="heart">
      
      <i class="iconfont">
        <svg class="icon" viewBox="0 0 1025 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="14" height="14">
  <path d="M1000.1 247.9c-15.5-37.3-37.6-70.6-65.7-98.9-54.4-54.8-125.8-85-201-85-85.7 0-166 39-221.4 107.4C456.6 103 376.3 64 290.6 64c-75.1 0-146.5 30.4-201.1 85.6-28.2 28.5-50.4 61.9-65.8 99.3-16 38.8-24 79.9-23.6 122.2 0.7 91.7 40.1 177.2 108.1 234.8 3.1 2.6 6 5.1 8.9 7.8 14.9 13.4 58 52.8 112.6 102.7 93.5 85.5 209.9 191.9 257.5 234.2 7 6.1 15.8 9.5 24.9 9.5 9.2 0 18.1-3.4 24.9-9.5 34.5-30.7 105.8-95.9 181.4-165 74.2-67.8 150.9-138 195.8-178.2 69.5-57.9 109.6-144.4 109.9-237.3 0.1-42.5-8-83.6-24-122.2z"
   fill="#8a8a8a"></path>
</svg>

      </i>
    </span><span class="author">
        Wang Junjie
        
      </span></span>

  
  
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont">
        
        <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="35" height="35">
  <path d="M510.866688 227.694839 95.449397 629.218702l235.761562 0-2.057869 328.796468 362.40389 0L691.55698 628.188232l241.942331-3.089361L510.866688 227.694839zM63.840492 63.962777l894.052392 0 0 131.813095L63.840492 195.775872 63.840492 63.962777 63.840492 63.962777zM63.840492 63.962777"></path>
</svg>

      </i>
    </div>
  </div>
  
<script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>




<script type="text/javascript" src="/js/main.dee43230127a73d039a734510fa896c89c3c7ce0cf0be0c7a7433f8fd69b76dc.js" integrity="sha256-3uQyMBJ6c9A5pzRRD6iWyJw8fODPC&#43;DHp0M/j9abdtw="></script>






  
    <script type="text/javascript" src="/js/load-photoswipe.js"></script>
    <script type="text/javascript" src="/lib/photoswipe/photoswipe.min.js"></script>
    <script type="text/javascript" src="/lib/photoswipe/photoswipe-ui-default.min.js"></script>
  













</body>
</html>
